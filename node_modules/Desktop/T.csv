References,Base+Rag,Base+Rag+Slim,Base+Slim,Base+Slim+OR,,
"The detailed placement module in OpenROAD (dpl) is based on OpenDP, or Open-Source Detailed Placement Engine. Its key features are:
Fence region.
Fragmented ROWs.
Commands

Detailed Placement

The detailed_placement command performs detailed placement of instances to legal locations after global placement.
detailed_placement
    [-max_displacement disp|{disp_x disp_y}]
    [-disallow_one_site_gaps]
    [-report_file_name filename]

Options

Switch Name
Description
-max_displacement
Max distance that an instance can be moved (in microns) when finding a site where it can be placed. Either set one value for both directions or set {disp_x disp_y} for individual directions. The default values are {0, 0}, and the allowed values within are integers [0, MAX_INT].
-disallow_one_site_gaps
Disable one site gap during placement check.
-report_file_name
File name for saving the report to (e.g. report.json.
Set Placement Padding

The set_placement_padding command sets left and right padding in multiples of the row site width. Use the set_placement_padding command before legalizing placement to leave room for routing. Use the -global flag for padding that applies to all instances. Use -instances for instance-specific padding. The instances insts can be a list of instance names, or an instance object returned by the SDC get_cells command. To specify padding for all instances of a common master, use the -filter ""ref_name == "" option to get_cells.
set_placement_padding   
    -global|-masters masters|-instances insts
    [-right site_count]
    [-left site_count]

Options

Either one of these flags must be set: `-global | -masters | -instances`.
The order of preference is `global > masters > instances`

Switch Name
Description
-global
Set padding globally using left and right values.
-masters
Set padding only for these masters using left and right values.
-instances
For -instances, you will set padding only for these insts using left and right values.
-left
Left padding (in site count).
-right
Right padding (in site count).
instances
Set padding for these list of instances. Not to be confused with the -instances switch above.
Filler Placement

The filler_placement command fills gaps between detail-placed instances to connect the power and ground rails in the rows. filler_masters is a list of master/macro names to use for filling the gaps. Wildcard matching is supported, so FILL* will match, e.g., FILLCELL_X1 FILLCELL_X16 FILLCELL_X2 FILLCELL_X32 FILLCELL_X4 FILLCELL_X8. To specify a different naming prefix from FILLER_ use -prefix <new prefix>.
filler_placement
    [-prefix prefix]
    filler_masters

Options

Switch Name
Description
-prefix
Prefix to name the filler cells. The default value is FILLER_.
filler_masters
Filler master cells.
Remove Fillers

This command removes all filler cells.
remove_fillers 

No arguments are needed for this function.
Check Placement

The check_placement command checks the placement legality. It returns 0 if the placement is legal.
check_placement
    [-verbose]
    [-disallow_one_site_gaps]
    [-report_filename filename]

Options

Switch Name
Description
-verbose
Enable verbose logging.
-disallow_one_site_gaps
Disable one site gap during placement check.
-report_file_name
File name for saving the report to (e.g. report.json.
Optimize Mirroring

The optimize_mirroring command mirrors instances about the Y axis in a weak attempt to reduce the total half-perimeter wirelength (HPWL).
optimize_mirroring

No arguments are needed for this function.
Useful Developer Commands

If you are a developer, you might find these useful. More details can be found in the source file or the swig file.
Command Name
Description
detailed_placement_debug
Debug detailed placement.
get_masters_arg
Get masters from a design.
get_inst_bbox
Get bounding box of an instance.
get_inst_grid_bbox
Get grid bounding box of an instance.
format_grid
Format grid (takes in length x and site width w as inputs).
get_row_site
Get row site name.
Example scripts

Examples scripts demonstrating how to run dpl on a sample design of aes as follows:
./test/aes.tcl

Regression tests

There are a set of regression tests in ./test. Refer to this section for more information.
Simply run the following script:
./test/regression

Limitations

FAQs

Check out GitHub discussion about this tool.
Authors

SangGi Do and Mingyu Woo (respective Ph. D. advisors: Seokhyeong Kang, Andrew B. Kahng).
Rewrite and port to OpenDB/OpenROAD by James Cherry, Parallax Software
References

Do, S., Woo, M., & Kang, S. (2019, May). Fence-region-aware mixed-height standard cell legalization. In Proceedings of the 2019 on Great Lakes Symposium on VLSI (pp. 259-262). (.pdf)
License

BSD 3-Clause License. See LICENSE file.","So you're asking about Detailed Placement in OpenROAD!

Detailed Placement, or DPL, is a module in OpenROAD that performs the actual placement of instances on the die after global placement. It's based on OpenDP, which is an open-source detailed placement engine.

In DPL, you can specify various options to control the placement process. For example, you can set the maximum displacement of an instance during placement using the `-max_displacement` option. You can also disable one-site gaps during placement using the `-disallow_one_site_gaps` option.

Additionally, you can set placement padding using the `set_placement_padding` command. This command allows you to specify left and right padding in multiples of the row site width. You can set padding globally, for specific masters, or for individual instances.

So, to summarize, Detailed Placement in OpenROAD is the process of placing instances on the die after global placement, and it's controlled by various options and commands to achieve the desired placement result.","Detailed Placement in OpenROAD is a step in the OpenROAD flow that involves placing instances onto legal locations after global placement. It is based on the OpenDP, or Open-Source Detailed Placement Engine, and has key features such as fence region, fragmented rows, and commands. These features help in efficiently placing instances and improving the overall layout of the design",,,,
"This tool is an implementation of Design For Testing. New nets and logic are added to allow IC designs to be tested for errors in manufacturing. Physical imperfections can cause hard failures and variability can cause timing errors.
A simple DFT insertion consist of the following parts:
A scan_in pin where the test patterns are shifted in.
A scan_out pin where the test patterns are read from.
Scan cells that replace flops with registers that allow for testing.
One or more scan chains (shift registers created from your scan cells).
A scan_enable pin to allow your design to enter and leave the test mode.
TCL Commands

set_dft_config

set_dft_config [-max_length <int>]
               [-clock_mixing <string>]

-max_length: The maxinum number of bits that can be in each scan chain.
-clock_mixing: How architect will mix the scan flops based on the clock driver.
no_mix: Creates scan chains with only one type of clock and edge. This may create unbalanced chains.
clock_mix: Craetes scan chains mixing clocks and edges. Falling edge flops are going to be stitched before rising edge.
report_dft_config

report_dft_config

Prints the current DFT configuration to be used by preview_dft and insert_dft.
preview_dft

preview_dft [-verbose]

Prints a preview of the scan chains that will be stitched by insert_dft. Use this command to iterate and try different DFT configurations. This command do not perform any modification to the design.
-verbose: Shows more information about each one of the scan chains that will be created.
insert_dft

insert_dft

Implements the scan chains into the design by performing the following actions:
Scan Replace.
Scan Architect.
Scan Stitch.
The end result will be a design with scan flops connected to form the scan chains.
Example

This example will create scan chains with a max length of 10 bits mixing all the scan flops in the scan chains.
set_dft_config -max_length 10 -clock_mixing clock_mix
report_dft_config
preview_dft -verbose
insert_dft

Limitations

There are no optimizations for the scan chains. This is a WIP.
There is no way to specify existing scan ports to be used by scan insertion.
There is currently no way to define a user defined scan path.
We can only work with one bit cells.","So, you're asking about DFT, which stands for Design For Testing. It's a technique used to add testability to integrated circuits (ICs) during the design phase, allowing for more efficient and effective testing of the ICs during manufacturing.

In the context of the tool you're using, DFT involves adding new nets and logic to the design to enable testing. This includes adding scan cells, scan chains, and other components to allow for the shifting of test patterns into and out of the design.

The tool you're using provides several commands to implement DFT, including `set_dft_config`, `report_dft_config`, `preview_dft`, and `insert_dft`. These commands allow you to configure the DFT settings, preview the scan chains that will be created, and finally implement the DFT into the design.

The commands you've provided give you an idea of how to use these commands to implement DFT in your design. For example, you can set the maximum length of the scan chains to 10 bits and mix the scan flops based on the clock driver using the `set_dft_config` command.

I hope that helps! Let me know if you have any further questions.","DFT stands for Design for Testing. It is a process of adding additional logic and pins to a design to make it easier to test for errors in manufacturing. The DFT process involves adding scan-in and scan-out pins, scan cells, and scan chains to the design. These components allow the design to be tested for errors in manufacturing, such as physical imperfections and timing errors. The DFT process is important because it helps ensure that the final product meets the required quality standards and is free of defects. It also helps reduce the cost of testing and debugging the design, which can be very expensive if done manually. In OpenROAD, DFT is implemented through the use of TCL commands, which allow users to specify the desired DFT configuration and insert the necessary logic and pins into the design. The DFT process in OpenROAD is a simple and straightforward process that can be easily understood and implemented by users. It is a powerful tool that helps ensure the quality of the final product and reduces the cost of testing and debugging.",,,,
"OpenSTA is a gate level static timing verifier. As a stand-alone executable it can be used to verify the timing of a design using standard file formats. OpenSTA uses a TCL command interpreter to read the design, specify timing constraints and print timing reports.

","OpenSTA! It's a powerful tool in the OpenROAD ecosystem, specifically designed for gate-level static timing analysis. As you mentioned, it's a standalone executable that can verify the timing of a design using standard file formats.

From what I understand, OpenSTA uses a TCL command interpreter to read the design, specify timing constraints, and then print out timing reports. This allows designers to identify potential timing issues and optimize their design for better performance.

Regarding the clocks supported in OpenSTA, it looks like they cover a range of scenarios, including generated clocks, latency, source latency, uncertainty, propagated/ideal clocks, and gated clock checks. This flexibility is likely useful for designers working with complex clock domains and timing constraints.

If you have any more questions about OpenSTA or its capabilities, feel free to ask!","Parallax Static Timing Analyzer or OpenSTA is a gate level static timing verifier. It is a stand-alone executable that can be used to verify the timing of a design using standard file formats. OpenSTA uses a TCL command interpreter to read the design, specify timing constraints, and print timing reports.",,,,
